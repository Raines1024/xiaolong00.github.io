---
layout: post
title: 《Effective java 3》读书笔记
description: 
category: blog
date: 2020-01-07 13:50:39
---

## 用静态工厂方法代替构造器

## 当构造方法参数过多时使用builder模式
构造方法参数过多解决方案：  
1. 重叠构造器模式：简而言之，重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难缩写，并且仍然较难以阅读。  
2. JavaBeans模式，在这种模式下，先调用一个无参构造器来创建对象，然后再调用setter方法来设置每个必要的参数，以及每个相关的可选参数。缺点也却而易见：因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态（譬如某个方法返回的属性值为null，不同调用中可能会缺失某个必需属性值）；JavaBeans模式使得把类做成不可变的可能性不复存在。这就需要程序员付出额外的努力来确保它的线程安全。
3. 建造者（Builder）模式。它不直接生成想要的对象，而是让客户端利用所有必要的参数调用构造器（或者静态工厂），得到一个builder对象，然后客户端在 builder 对象上调用类似于setter的方法，来设置每个相关的可选参数。最后，客户端调用无参的build方法来生成通常是不可变的对象。这个builder通常是它构建的类的静态成员类。

## 用私有构造器或者枚举类型强化Singleton属性
Singleton是指仅仅被实例化一次的类。  
单元素的枚举类型经常成为实现Singleton的最佳方法。

## 通过私有构造器强化不可实例化的能力
创建私有构造器并在其中抛出AssertionError
避免工具类误操作而实例化  

## 优先考虑依赖注入来引用资源
在创建新实例时将资源传递到构造器中，这是依赖项注入（dependency injection）的一种形式。  
不要用singleton和静态工具类来实现依赖一个或多个底层资源的类，且该资源的行为会影响到该类的行为；也不要直接用这个类来创建这些资源，而应该将这些资源或者工厂传给构造器（或者静态工厂，或者构建器），通过它们来创建类。这个实践就被称作依赖注入，它极大地提升了类的灵活性、可重用性和可测试性。

## 避免创建不必要的对象

## 消除过期的对象引用

## 避免使用 Finalizer 和 Cleaner 机制

## 9. 使用 try-with-resources 语句替代 try-finally 语句

## 10. 重写 equals 方法时遵守通用约定








































